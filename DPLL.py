# -*- coding: utf-8 -*-
"""EP22B004.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jTZHo97xvF9mZYacZMT16fDWrG09ZVSc
"""

'''!wget https://raw.githubusercontent.com/tric/trick2015/master/ksk_2/unsat.cnf

!wget https://raw.githubusercontent.com/srini229/EE5333_tutorials/master/misc/1.cnf
!wget https://raw.githubusercontent.com/srini229/EE5333_tutorials/master/misc/uf20-01.cnf
!wget https://raw.githubusercontent.com/srini229/EE5333_tutorials/master/misc/uf20-02.cnf
!wget https://raw.githubusercontent.com/srini229/EE5333_tutorials/master/misc/uf20-03.cnf
!wget https://raw.githubusercontent.com/srini229/EE5333_tutorials/master/misc/uf20-04.cnf
!wget https://raw.githubusercontent.com/srini229/EE5333_tutorials/master/misc/uf20-05.cnf'''

import random

class Clause:
    def __init__(self, vl):
        self._vars = [v for v in vl]
        self._vact = [True for v in vl]
        self._nact = len(self._vars)
        self._val  = None

    def eval(self, m):
        val = False
        self._nact = 0
        for i in range(len(self._vars)):
            v = self._vars[i]
            lval = m[abs(v)]
            if lval is None:
                self._vact[i] = True
                self._nact += 1
            else:
                if (v > 0 and lval) or (v < 0 and not lval):
                    return True
                self._vact[i] = False
        return False if self._nact == 0 else None

    def getUnitVal(self):
        if self._nact == 1:
            for i in range(len(self._vars)):
                if self._vact[i]:
                    return self._vars[i]
        return None

    def propagate(self, m):
        self._val = self.eval(m)
        return self._val

    def __repr__(self):
        return '[' + str(self._vars) + ' ' + str(self._vact) + ' ' + str(self._nact) + ' ' + str(self._val) + ']'


def unitClauses(f):
    return [c for c in f if c._val is None and c._nact == 1]


def pureLiterals(f, m):
    counts = {}
    for c in f:
        if c._val is not None:
            continue
        for i, v in enumerate(c._vars):
            if c._vact[i]:
                counts[v] = counts.get(v, 0) + 1

    pure = []
    for v in range(1, len(m)):
        if m[v] is not None:
            continue
        if v in counts and -v not in counts:
            pure.append(v)
        elif -v in counts and v not in counts:
            pure.append(-v)
    return pure


def pickBranchingLiteral(f, m):
    counts = {}
    for clause in f:
        if clause._val is not None:
            continue
        for i, v in enumerate(clause._vars):
            if clause._vact[i] and m[abs(v)] is None:
                counts[v] = counts.get(v, 0) + 1
    if not counts:
        return None
    return max(counts, key=counts.get)  # Return most frequent literal with polarity




def dpll(f, m):
    changed = True
    while changed:
        changed = False
        for c in f:
            c.propagate(m)

        # Unit propagation
        unit = unitClauses(f)
        while unit:
            for c in unit:
                lit = c.getUnitVal()
                if lit is None:
                    continue
                var = abs(lit)
                val = lit > 0
                if m[var] is not None and m[var] != val:
                    return False, None  # Conflict
                if m[var] is None:
                    m[var] = val
                    changed = True
            for c in f:
                c.propagate(m)
            unit = unitClauses(f)

        # Pure literal elimination
        pl = pureLiterals(f, m)
        for lit in pl:
            var = abs(lit)
            val = lit > 0
            if m[var] is None:
                m[var] = val
                changed = True

    # Check if all clauses are satisfied
    if all(c._val == True for c in f):
        return True, m

    # Check for unsatisfied clause
    if any(c._val == False for c in f):
        return False, None

    # Branching
    lit = pickBranchingLiteral(f, m)
    if lit is None:
        return True, m

    var = abs(lit)
    for val in [lit > 0, lit < 0]:
        m_copy = m[:]
        m_copy[var] = val
        f_copy = [Clause(c._vars[:]) for c in f]
        sat, m_ret = dpll(f_copy, m_copy)
        if sat:
            return True, m_ret
    return False, None




def loadCNFFile(fn):
    numvars = 0
    numclauses = 0
    clauses = []
    with open(fn, 'r') as fs:
        for line in fs:
            if line[0] == '%': break
            if line[0] == 'p':
                numvars = int(line.split()[2])
                numclauses = int(line.split()[3])
                continue
            if line[0] == 'c': continue
            if numvars > 0:
                tmp = line.split()
                tmp = [int(tmp[i]) for i in range(len(tmp) - 1)]
                clauses.append(Clause(tmp))
                for v in tmp:
                    assert abs(v) <= numvars
    assert len(clauses) == numclauses
    return numvars, clauses


if __name__ == '__main__':
    import argparse
    import sys
    ap = argparse.ArgumentParser()
    ap.add_argument("-c", "--cnf", type=str, default="", help='<cnf file>')
    args, unknown = ap.parse_known_args()  # <--- This prevents crash from unknown args
    import time
    if args.cnf != "":
        print(f"CNF file  : {args.cnf}")
        numvars, clauses = loadCNFFile(args.cnf)
        m = [None for i in range(numvars + 1)]
        t1 = time.time()
        ret, m = dpll(clauses, m)
        t2 = time.time()
        if ret:
            print("SAT")
            print("Prints True with a \"-\" sign and False normally as given in slides")
            print([(-i if m[i] == True else i) for i in range(1, len(m))])
            print(t2-t1)
        else:
            print("UNSAT")

