# -*- coding: utf-8 -*-
"""EP22B004.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gPSBFkY0lwyWr5cyBeFSyfqCVubckW1s
"""

import random
import math
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
import copy #Required to create deepcopies at time since issues were faced in variable updates

class Module:
    def __init__(self, name, area, aspect_ratios):
        self._area = area
        self._name = name
        self._wh = [(math.sqrt(area * r), math.sqrt(area / r)) for r in aspect_ratios]

    def __repr__(self):
        return f"{self._name} area:{self._area} xy = {self._wh}"

class Seqpair:
    def __init__(self, Modules):
        self._pos = [i for i in range(len(Modules))]
        self._neg = [i for i in range(len(Modules))]
        random.shuffle(self._pos)
        random.shuffle(self._neg) #Shuffling gives me a better result since I increase my possibility to be closer to a point satisfying the aspect ration
        self._asprat = [0 for i in range(len(Modules))]
        self._coords = [(0, 0) for _ in range(len(Modules))]
        self._w = 0
        self._h = 0

    def perturb(self, modules):
        movetype = random.randint(0, 2)
        match movetype:
            case 0: #Only Positive
                i, j = random.sample(range(len(modules)), 2)
                self._pos[i], self._pos[j] = self._pos[j], self._pos[i]
            case 1: #Both Positive and Negative
                i, j = random.sample(range(len(modules)), 2)
                a, b = self._pos[i], self._pos[j]
                ia, ib = self._neg.index(a), self._neg.index(b)
                self._neg[ia], self._neg[ib] = self._neg[ib], self._neg[ia]
                self._pos[i], self._pos[j] = self._pos[j], self._pos[i]
            case 2: #Aspect Ratios
                i = random.randint(0,len(modules)-1)
                self._asprat[i] = random.randint(0,len(modules[i]._wh)-1)
    def GraphFormer(self,modules):
        E_hcg, E_vcg = [], []
        pos_indices = {value: idx for idx, value in enumerate(self._pos)}
        neg_indices = {value: idx for idx, value in enumerate(self._neg)} #Dictionaries work better than nested list for the forms of graph

        for a in range(len(self._pos)):
            for b in range(len(self._pos)):
                if a == b: continue
                ap, bp = pos_indices[a], pos_indices[b]
                an, bn = neg_indices[a], neg_indices[b]
                if ap < bp and an < bn:
                    E_hcg.append((a, b))
                elif ap < bp and an > bn:
                    E_vcg.append((a, b)) #Works like a->b in graph
        return E_hcg, E_vcg

    def SolveCoords(self, edges, Modules, direction): #Making the Queue for cost calculation
        coords = [0.0] * len(Modules)
        adj_list = [[] for _ in range(len(Modules))]
        indegree = [0] * len(Modules)

        for u, v in edges:
            adj_list[u].append(v)
            indegree[v] += 1

        queue = [i for i in range(len(Modules)) if indegree[i] == 0]

        while queue:
            u = queue.pop(0)
            u_size = Modules[u]._wh[self._asprat[u]][direction]
            for v in adj_list[u]:
                coords[v] = max(coords[v], coords[u] + u_size)
                indegree[v] -= 1
                if indegree[v] == 0:
                    queue.append(v)
        return coords

    def costEval(self, Modules): #Area calculation after plotting coordinates
        E_hcg, E_vcg = self.GraphFormer(Modules)
        x_coords = self.SolveCoords(E_hcg, Modules, 0)
        y_coords = self.SolveCoords(E_vcg, Modules, 1)
        self._coords = list(zip(x_coords, y_coords))
        self._w = max(x_coords[i] + Modules[i]._wh[self._asprat[i]][0] for i in range(len(Modules)))
        self._h = max(y_coords[i] + Modules[i]._wh[self._asprat[i]][1] for i in range(len(Modules)))
        return self._w * self._h

#Simulated annealing code - As given in Assignment Sheet - Aspect ration constraint added

def accept(delC, T):
    return delC <= 0 or random.random() < math.exp(-delC / T)


def simulated_annealing(Tmin, Tmax, N_iter_per_Temp, alpha, S_init, modules, ARmin, ARmax):
    T = Tmax
    S = copy.deepcopy(S_init)
    C = S.costEval(modules)
    minC, minS = C, copy.deepcopy(S)

    while T > Tmin:
        for _ in range(N_iter_per_Temp):
            Snew = copy.deepcopy(S)
            Snew.perturb(modules)
            Cnew = Snew.costEval(modules)

            aspectRatio = Snew._w / Snew._h
            if accept(Cnew - C, T) and ARmin <= aspectRatio <= ARmax:
                S, C = Snew, Cnew

                if C < minC:
                    minC, minS = C, Snew
        T *= alpha

    return minS, minC

#As given in sheet
def sp_floorplan(modules, ARmin, ARmax):
    S = Seqpair(modules)
    Tmax = sum(m._area for m in modules) * 10
    Tmin = 1e-3 * Tmax
    Smin, Cmin = simulated_annealing(Tmin, Tmax, 100, 0.9, S, modules, ARmin, ARmax)
    ar = Smin._w/Smin._h
    sol = [(Smin._coords[i], modules[i]._wh[Smin._asprat[i]], modules[i]._name) for i in range(len(modules))]
    return sol, Cmin, ar

#As given in sheet
def plot(coords):
    fig, ax = plt.subplots()
    ax.set_aspect('equal')
    ax.set_xlim(0, max(r[0][0] + r[1][0] for r in coords))
    ax.set_ylim(0, max(r[0][1] + r[1][1] for r in coords))

    for i, r in enumerate(coords):
        color = ['gray', 'blue', 'green', 'red'][i % 4]
        ax.add_patch(Rectangle(r[0], r[1][0], r[1][1], edgecolor=color, facecolor='none', lw=2))
        ax.text(r[0][0] + r[1][0] / 2, r[0][1] + r[1][1] / 2, r[2], fontsize=8, ha='center', va='center')
    plt.show()

#Test module with 4 block - As given in sheet
m =[Module('a',16,[0.25,4]),Module('b',32,[2.0,0.5]),Module('c',27,[1./3,3.]),\
 Module('d',6,[6])]
sol,area,ar=sp_floorplan(m,0.75,1.33)
plot(sol)
print(sol)

#Randomnly Generated tests
m =[Module(str(i),random.randint(10,100),[0.75,1,1.33]) for i in range(60)]
sol,area,ar=sp_floorplan(m,0.5,2)
plot(sol)
reqarea = 0
for i in m:
    reqarea += i._area
print(reqarea,area,reqarea/area*100,ar)