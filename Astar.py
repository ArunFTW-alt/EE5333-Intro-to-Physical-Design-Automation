# -*- coding: utf-8 -*-
"""EP22B004.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hxv8W4hZb1_fwj7cxCB3FJDmIjxgGjUr
"""

import math
import heapq as hq

class Vertex:
    def __init__(self,x,y,cost=math.inf,parent=None,nbrs=None):
        self._xy = (x,y)
        self._g = None
        self._h = None
        self._cost = cost
        self._parent = parent
        self._nbrs = nbrs

    def __lt__(self,other):
        return self._cost < other._cost

    def __eq__(self,other):
        return isinstance(other,Vertex) and self._xy == other._xy

    def __hash__(self):
        return hash(self._xy) #Vertices are going to be hashed in priority queue class

    def __repr__(self):
        return f'(xy:{self._xy},cost:{self._cost})'

import itertools
class priority_queue:
    REMOVED = "<removed-task>" #Will keep an eye on the vertices removed from the queue

    def __init__(self,vertices = []):
        self._q = []
        self._tracker = {}
        self._counter = itertools.count()
        for v in vertices:
            self.push(v)

    def push(self,v):
        count = next(self._counter)
        entry = [v._cost,count, v]
        self._tracker[v] = entry #This is the hashing. To make this a valid one, we need __hash__ function in the vertex class
        hq.heappush(self._q,entry)

    def pop(self):
        while self._q:
            _, _, v = hq.heappop(self._q)
            if v != self.REMOVED:
                del self._tracker[v]
                return v

    def update(self, v, cost):
        if v in self._tracker:
            oldentry = self._tracker.pop(v)
            oldentry[2] = self.REMOVED
        v._cost = cost
        self.push(v)

    def empty(self):
        return all(entry[2] == self.REMOVED for entry in self._q) #In push function, entry is pushed in q only

    def __contains__(self,v):
        return v in self._tracker and self._tracker[v][2] != self.REMOVED

    def __repr__(self):
        return all(entry[2] for entry in self._q if entry[2] != self.REMOVED)

def dist(u,v):
    return (abs(u._xy[0]-v._xy[0]) + abs(u._xy[1]-v._xy[1]))

def astar(V,s,t):
    s._g, s._h = 0, dist(s,t)
    s._cost = 0
    for v in V:
        if v != s:
            v._g = math.inf
            v._h = None
            v._parent = None
            v._cost = math.inf

    Q = priority_queue([s])
    visited = set()
    while not Q.empty():
        u = Q.pop()
        if u in visited:
            continue
        visited.add(u)
        if u == t:
            break
        for v in u._nbrs:
            newg = u._g + dist(u,v)
            if newg < v._g:
                v._g = newg
                if v._h is None:
                    v._h = dist(v,t)
                v._parent = u
                v._cost = newg + v._h
                if v in Q:
                    Q.update(v,v._cost)
                else:
                    Q.push(v)
    if t._parent is None and t!=s:
        return []
    path = [t]
    while path[-1]._parent is not None:
        path.append(path[-1]._parent)
    path.reverse()
    return path

'''Vertices = [Vertex(0, 0, -1), Vertex(0,10,-1), Vertex(5,5,-1), Vertex(5,10,-1), Vertex(10,10,-1)]
Vertices[0]._nbrs = [Vertices[1], Vertices[2]]
Vertices[1]._nbrs = [Vertices[0], Vertices[4]]
Vertices[2]._nbrs = [Vertices[1], Vertices[3]]
Vertices[3]._nbrs = [Vertices[2], Vertices[4]]
Vertices[4]._nbrs = [Vertices[1], Vertices[3]]
for alg in [astar]:
  src = Vertices[0]
  tgt = Vertices[-1]
  print('src :', src, ' tgt :', tgt, 'path :', alg(Vertices, src, tgt))'''

'''import random
Vertices = [Vertex(random.randint(0,1000), random.randint(0,1000), -1) for i in range(10000)]
for v in Vertices:
  if v._nbrs is None: v._nbrs = list()
  for i in range(random.randint(1, 2)):
    nbr = Vertices[random.randint(0, len(Vertices)-1)]
    if nbr._nbrs is None: nbr._nbrs = list()
    v._nbrs.append(nbr)
    nbr._nbrs.append(v)

for alg in [astar]:
  src = Vertices[0]
  tgt = Vertices[-1]
  import time
  t = time.time()
  path1 = alg(Vertices, src, tgt)
  print('src :', src, ' tgt :', tgt, 'path :', path1, time.time() - t)'''

