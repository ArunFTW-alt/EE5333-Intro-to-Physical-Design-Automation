# -*- coding: utf-8 -*-
"""EP22B004.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ogAkDRlt_JIRMj-U0XpR5gyn2AU8lNN9
"""

!pip install --break-system-packages https://raw.githubusercontent.com/srini229/EE5333_tutorials/master/parser/LEFDEFParser-0.1-cp311-cp311-linux_x86_64.whl
!wget https://raw.githubusercontent.com/srini229/EE5333_tutorials/master/project/gr/c17.guide
!wget https://raw.githubusercontent.com/srini229/EE5333_tutorials/master/project/lef/sky130.lef
!wget https://raw.githubusercontent.com/srini229/EE5333_tutorials/master/project/def/c17.def
!pip install rtree

!wget https://raw.githubusercontent.com/srini229/EE5333_tutorials/master/project/sol/checker.py

!wget https://raw.githubusercontent.com/srini229/EE5333_tutorials/master/project/def/c499.def
!wget https://raw.githubusercontent.com/srini229/EE5333_tutorials/master/project/def/c432.def
!wget https://raw.githubusercontent.com/srini229/EE5333_tutorials/master/project/gr/c432.guide
!wget https://raw.githubusercontent.com/srini229/EE5333_tutorials/master/project/gr/c499.guide

!wget https://raw.githubusercontent.com/srini229/EE5333_tutorials/master/project/def/c6288.def
!wget https://raw.githubusercontent.com/srini229/EE5333_tutorials/master/project/gr/c6288.guide

!wget https://raw.githubusercontent.com/srini229/EE5333_tutorials/master/project/def/add5.def
!wget https://raw.githubusercontent.com/srini229/EE5333_tutorials/master/project/gr/add5.guide

leffile = 'sky130.lef'
deffile = 'c17.def'
gr_filepath = 'c17.guide'

import LEFDEFParser
import numpy as np
import math
from collections import defaultdict
import heapq
import rtree
import io
import sys
import ast
import time
from typing import List, Dict, Tuple, Any, Set, Optional

mySkipCellNames = {
    "sky130_fd_sc_hd__decap_3", "sky130_fd_sc_hd__decap_4", "sky130_fd_sc_hd__decap_6", "sky130_fd_sc_hd__decap_8",
    "sky130_fd_sc_hd__decap_12", "sky130_fd_sc_hd__fill_1", "sky130_fd_sc_hd__fill_2", "sky130_fd_sc_hd__fill_4",
    "sky130_fd_sc_hd__fill_8", "sky130_fd_sc_hd__lpflow_decapkapwr_3", "sky130_fd_sc_hd__lpflow_decapkapwr_4",
    "sky130_fd_sc_hd__lpflow_decapkapwr_6", "sky130_fd_sc_hd__lpflow_decapkapwr_8", "sky130_fd_sc_hd__lpflow_decapkapwr_12",
    "sky130_fd_sc_hd__lpflow_lsbuf_lh_hl_isowell_tap_1", "sky130_fd_sc_hd__lpflow_lsbuf_lh_hl_isowell_tap_2",
    "sky130_fd_sc_hd__lpflow_lsbuf_lh_hl_isowell_tap_4", "sky130_fd_sc_hd__lpflow_lsbuf_lh_isowell_tap_1",
    "sky130_fd_sc_hd__lpflow_lsbuf_lh_isowell_tap_2", "sky130_fd_sc_hd__lpflow_lsbuf_lh_isowell_tap_4", "sky130_fd_sc_hd__tap_1",
    "sky130_fd_sc_hd__tap_2", "sky130_fd_sc_hd__tapvgnd2_1", "sky130_fd_sc_hd__tapvgnd_1",
    "sky130_fd_sc_hd__tapvpwrvgnd_1", "sky130_ef_sc_hd__decap_12"
}

myLayerColorMap= {
    'li1': 'red', 'met1': 'blue', 'met2': 'green', 'met3': 'orange', 'met4': 'magenta', 'met5': 'cyan'
}

myLayerOrientationMap= {
    'li1': 'VERTICAL', 'met1': 'HORIZONTAL', 'met2': 'VERTICAL', 'met3': 'HORIZONTAL', 'met4': 'VERTICAL', 'met5': 'HORIZONTAL'
}

mySkipNetNames = {'clk', 'VPWR', 'VGND', 'clknet_0_clk', 'clknet_2_0__leaf_clk', 'clknet_2_1__leaf_clk', 'clknet_2_2__leaf_clk', 'clknet_2_3__leaf_clk'}
myRailNetNames = {'VPWR', 'VGND'}

gAdjacentLayerMap = {'li1': ['met1'],
    'met1': ['li1', 'met2'],
    'met2': ['met1', 'met3'],
    'met3': ['met2', 'met4'],
    'met4': ['met3', 'met5'],
    'met5': ['met4']
}

myLayerWidthMap= {}
myLayerSpacingMap = {}

from checker import *

class InstanceData:
    def __init__(self, comp: LEFDEFParser.Component, macro: LEFDEFParser.Macro):
        self._comp = comp
        self._macro = macro
        origin = comp.location()
        self._bBox = LEFDEFParser.Rect(origin.x, origin.y, origin.x + macro.xdim(), origin.y + macro.ydim())
        self._shape = {}
        self._obstructionShapes = defaultdict(list)

        for pin in macro.pins():
            layer_shapes = defaultdict(list)
            for port in pin.ports():
                for layer, rects in port.items():
                    if layer not in myLayerColorMap:
                        continue
                    for rect in rects:
                        t_rect = LEFDEFParser.Rect(rect.ll.x, rect.ll.y, rect.ur.x, rect.ur.y)
                        t_rect.transform(comp.orient(), origin, macro.xdim(), macro.ydim())
                        layer_shapes[layer].append(t_rect)
            self._shape[pin.name()] = layer_shapes

        for layer, rects in macro.obstructions().items():
            if layer not in myLayerColorMap:
                continue
            for rect in rects:
                t_rect = LEFDEFParser.Rect(rect.ll.x, rect.ll.y, rect.ur.x, rect.ur.y)
                t_rect.transform(comp.orient(), origin, macro.xdim(), macro.ydim())
                self._obstructionShapes[layer].append(t_rect)

        for pin in macro.pins():
            if pin.name() in myRailNetNames:
                if pin.ports() and 'met1' in pin.ports()[0] and pin.ports()[0]['met1']:
                    rect = pin.ports()[0]['met1'][0]
                    t_rect = LEFDEFParser.Rect(rect.ll.x, rect.ll.y, rect.ur.x, rect.ur.y)
                    t_rect.transform(comp.orient(), origin, macro.xdim(), macro.ydim())
                    self._obstructionShapes['met1'].append(t_rect)


class NetData:
    def __init__(self, netDef, instanceMap, boundaryPinMap, netIdentifier, wireLengthEstimate):
        self._netName = netDef.name()
        self._pinConnections = {}
        self._netIdentifier = netIdentifier
        self._routingSolution = defaultdict(list)
        self._wireLengthEstimate = wireLengthEstimate

        for pin in netDef.pins():
            inst_name, pin_name = pin
            if inst_name in instanceMap:
                self._pinConnections[pin] = instanceMap[inst_name]._shape.get(pin_name, {})
            elif inst_name == 'PIN' and pin_name in boundaryPinMap:
                self._pinConnections[pin] = boundaryPinMap[pin_name]


class GraphVertex:
    def __init__(self, x, y, layers, g_cost=math.inf, parent=None, neighbors=None):
        self._coordinates = (x, y)
        self._layerContext = layers
        self._costG = g_cost
        self._costH = None
        self._parentNode = parent
        self._neighborNodes = neighbors if neighbors is not None else []

    def resetStateForSearch(self):
        self._costG = math.inf
        self._costH = None
        self._parentNode = None

    def __lt__(self, other):
        cost_f_self = self._costG + (self._costH if self._costH is not None else 0)
        cost_f_other = other._costG + (other._costH if other._costH is not None else 0)
        if abs(cost_f_self - cost_f_other) < 1e-9:
            return self._costG > other._costG
        return cost_f_self < cost_f_other

    def __eq__(self, other):
        if not isinstance(other, GraphVertex):
            return NotImplemented
        return self._coordinates == other._coordinates

    def __hash__(self):
        return hash(self._coordinates)

    def __repr__(self):
        h_cost = f"{self._costH:.2f}" if self._costH is not None else "N/A"
        return f"(xy:{self._coordinates}, layers:{self._layerContext}, gCost:{self._costG:.2f}, hCost:{h_cost})"


class PriorityQueue:
    def __init__(self, items=None):
        self._heap = items if items is not None else []
        heapq.heapify(self._heap)

    def pushItem(self, item):
        heapq.heappush(self._heap, item)

    def popItem(self):
        return heapq.heappop(self._heap)

    def updateItem(self, item, new_cost):
        try:
            idx = self._heap.index(item)
            self._heap[idx]._costG = new_cost
            heapq.heapify(self._heap)
        except ValueError:
            pass

    def isEmpty(self):
        return not self._heap

    def __contains__(self, item):
        return item in self._heap

    def __repr__(self):
        return str(self._heap)

def dist(vertexOne, vertexTwo) -> int:
    return abs(vertexOne._coordinates[0] - vertexTwo._coordinates[0]) + \
           abs(vertexOne._coordinates[1] - vertexTwo._coordinates[1])

def buildTree(netDataList, instanceDataMap: Dict[str, InstanceData]):
    Map = {layer: rtree.index.Index() for layer in myLayerColorMap}
    fixedObstacleId = len(netDataList)
    count = 0
    for instanceObj in instanceDataMap.values():
        for layerName, obstructionRectList in instanceObj._obstructionShapes.items():
            if layerName in Map:
                for rectShape in obstructionRectList:
                    Map[layerName].insert(count,
                                                 (rectShape.ll.x, rectShape.ll.y, rectShape.ur.x, rectShape.ur.y),
                                                 obj=fixedObstacleId)
                    count += 1

    return Map, count, fixedObstacleId


def overlap1(rectTupleA: Tuple[int,int,int,int], rectTupleB: Tuple[int,int,int,int]) -> bool:
    minXA, minYA, maxXA, maxYA = rectTupleA
    minXB, minYB, maxXB, maxYB = rectTupleB
    return not (maxXA <= minXB or maxXB <= minXA or maxYA <= minYB or maxYB <= minYA)

def combineOverlappingRectangles(rectTupleA: Tuple[int,int,int,int], rectTupleB: Tuple[int,int,int,int]) -> Tuple[int,int,int,int]:
    return (min(rectTupleA[0], rectTupleB[0]), min(rectTupleA[1], rectTupleB[1]),
            max(rectTupleA[2], rectTupleB[2]), max(rectTupleA[3], rectTupleB[3]))

def mergeRectangleList(inputRectangleTupleList: List[Tuple[int,int,int,int]]) -> List[Tuple[int,int,int,int]]:
    if not inputRectangleTupleList:
        return []

    processedRects = list(inputRectangleTupleList)
    finalMergedList: List[Tuple[int,int,int,int]] = []

    while processedRects:
        baseRect = processedRects.pop(0)
        currentRectIndex = 0
        mergedInThisPass = True
        while mergedInThisPass:
            mergedInThisPass = False
            currentRectIndex = 0
            while currentRectIndex < len(processedRects):
                if overlap1(baseRect, processedRects[currentRectIndex]):
                    baseRect = combineOverlappingRectangles(baseRect, processedRects.pop(currentRectIndex))
                    mergedInThisPass = True
                else:
                    currentRectIndex += 1
        finalMergedList.append(baseRect)
    return finalMergedList

def generateGridTracksInGuide(outputGridTrackSegmentsMap: Dict[str, Dict[int, List[Tuple[int,int]]]],
                              chipTrackLayoutMap: Dict[str, Dict[int, List[Tuple[int,int]]]],
                              targetLayerName: str,
                              trackOrientationChar: str,
                              guideRectangleTuple: Tuple[int,int,int,int]):
    guideMinX, guideMinY, guideMaxX, guideMaxY = guideRectangleTuple

    if trackOrientationChar == 'H':

        for yTrackCoord, chipExtentSegmentList in chipTrackLayoutMap.get(targetLayerName, {}).items():
            if guideMinY <= yTrackCoord <= guideMaxY:
                for chipMinX, chipMaxX in chipExtentSegmentList:

                    segmentStartX = max(guideMinX, chipMinX)
                    segmentEndX = min(guideMaxX, chipMaxX)
                    if segmentStartX < segmentEndX:
                        outputGridTrackSegmentsMap[targetLayerName][yTrackCoord].append((segmentStartX, segmentEndX))

    elif trackOrientationChar == 'V':
        for xTrackCoord, chipExtentSegmentList in chipTrackLayoutMap.get(targetLayerName, {}).items():
            if guideMinX <= xTrackCoord <= guideMaxX:
                for chipMinY, chipMaxY in chipExtentSegmentList:
                    segmentStartY = max(guideMinY, chipMinY)
                    segmentEndY = min(guideMaxY, chipMaxY)
                    if segmentStartY < segmentEndY:
                        outputGridTrackSegmentsMap[targetLayerName][xTrackCoord].append((segmentStartY, segmentEndY))

def consolidateTrackSegments(track_map):
    if not track_map:
        return

    for coord, segments in track_map.items():
        if segments and len(segments) > 1:
            segments.sort(key=lambda s: s[0])
            merged = [segments[0]]

            for start, end in segments[1:]:
                last_start, last_end = merged[-1]
                if start <= last_end + 1:
                    merged[-1] = (last_start, max(last_end, end))
                else:
                    merged.append((start, end))

            track_map[coord] = merged


def findAllTrackIntersections(horizontalTrackSegmentsMap: Dict[int, List[Tuple[int,int]]],
                              verticalTrackSegmentsMap: Dict[int, List[Tuple[int,int]]]) -> List[Tuple[int,int]]:
    intersectionPoints: List[Tuple[int,int]] = []
    for yHorizontalCoord, xSegmentList in horizontalTrackSegmentsMap.items():
        for xMinHorizontal, xMaxHorizontal in xSegmentList:
            for xVerticalCoord, ySegmentList in verticalTrackSegmentsMap.items():
                for yMinVertical, yMaxVertical in ySegmentList:
                    if (xMinHorizontal <= xVerticalCoord <= xMaxHorizontal) and \
                       (yMinVertical <= yHorizontalCoord <= yMaxVertical):
                        intersectionPoints.append((xVerticalCoord, yHorizontalCoord))
    return list(set(intersectionPoints))

def buildRoutingGraph(activeLayerPairsForNet: Set[Tuple[str,str]],
                      refinedGuidesByLayer: Dict[str, List[Tuple[int,int,int,int]]],
                      currentNetPinShapesToIgnore: Dict[str, List[List[int]]],
                      processedTrackSegmentsForNet: Dict[str, Dict[int, List[Tuple[int,int]]]],
                      mainSpatialIndex: Dict[str, rtree.index.Index],
                      li1PinSpatialIndex: rtree.index.Index,
                      layerOrientationMapGlobal: Dict[str, str],
                      fixedObstacleIdentifier: int,
                      routeAggressivelyFlag: bool) -> Dict[Tuple[int,int], GraphVertex]:

    graphVertexMap: Dict[Tuple[int,int], GraphVertex] = {}
    intersectionsByLayerPair: Dict[Tuple[str,str], Set[Tuple[int,int]]] = {}

    sortedActiveLayerPairs = sorted(list(activeLayerPairsForNet))

    for currentLayerPairTuple in sortedActiveLayerPairs:
        obstaclesForCurrentSegments: Dict[str, List[Tuple[int,int,int,int]]] = defaultdict(list)

        horizontalLayerName, verticalLayerName = "", ""
        if layerOrientationMapGlobal.get(currentLayerPairTuple[0]) == 'HORIZONTAL' and \
           layerOrientationMapGlobal.get(currentLayerPairTuple[1]) == 'VERTICAL':
            horizontalLayerName, verticalLayerName = currentLayerPairTuple[0], currentLayerPairTuple[1]
        elif layerOrientationMapGlobal.get(currentLayerPairTuple[1]) == 'HORIZONTAL' and \
             layerOrientationMapGlobal.get(currentLayerPairTuple[0]) == 'VERTICAL':
            horizontalLayerName, verticalLayerName = currentLayerPairTuple[1], currentLayerPairTuple[0]
        else:
            continue

        for layerInPair in [horizontalLayerName, verticalLayerName]:
            if layerInPair not in refinedGuidesByLayer or not refinedGuidesByLayer[layerInPair]:
                continue

            for guideRectTuple in refinedGuidesByLayer[layerInPair]:
                guideMinX, guideMinY, guideMaxX, guideMaxY = guideRectTuple
                if layerInPair in mainSpatialIndex:
                    for rtreeItem in list(mainSpatialIndex[layerInPair].intersection(
                                          (guideMinX, guideMinY, guideMaxX, guideMaxY), objects=True)):
                        if rtreeItem.bbox in currentNetPinShapesToIgnore.get(layerInPair, []):
                            continue

                        if routeAggressivelyFlag:
                            if rtreeItem.object == fixedObstacleIdentifier:
                                obstaclesForCurrentSegments[layerOrientationMapGlobal[layerInPair]].append(rtreeItem.bbox)
                        else:
                            obstaclesForCurrentSegments[layerOrientationMapGlobal[layerInPair]].append(rtreeItem.bbox)
                if layerInPair == 'met1' and li1PinSpatialIndex:
                    for li1RtreeItem in list(li1PinSpatialIndex.intersection(
                                             (guideMinX, guideMinY, guideMaxX, guideMaxY), objects=True)):

                        if li1RtreeItem.bbox in currentNetPinShapesToIgnore.get('met1', []):
                            continue
                        obstaclesForCurrentSegments[layerOrientationMapGlobal['met1']].append(li1RtreeItem.bbox)

        if not (horizontalLayerName in processedTrackSegmentsForNet and \
                verticalLayerName in processedTrackSegmentsForNet and \
                processedTrackSegmentsForNet[horizontalLayerName] and \
                processedTrackSegmentsForNet[verticalLayerName]):
            continue

        intersectionPointsForPair = findAllTrackIntersections(
            processedTrackSegmentsForNet[horizontalLayerName],
            processedTrackSegmentsForNet[verticalLayerName]
        )
        intersectionsByLayerPair[currentLayerPairTuple] = set(intersectionPointsForPair)

        for pointCoords in intersectionPointsForPair:
            if pointCoords not in graphVertexMap:
                graphVertexMap[pointCoords] = GraphVertex(pointCoords[0], pointCoords[1], list(currentLayerPairTuple))
            else:
                existingVertex = graphVertexMap[pointCoords]
                for layerToAdd in currentLayerPairTuple:
                    if layerToAdd not in existingVertex._layerContext:
                        existingVertex._layerContext.append(layerToAdd)


        pointsByYCoordOnHLayer: Dict[int, List[int]] = defaultdict(list)
        pointsByXCoordOnVLayer: Dict[int, List[int]] = defaultdict(list)
        for xCoord, yCoord in intersectionPointsForPair:
            pointsByYCoordOnHLayer[yCoord].append(xCoord)
            pointsByXCoordOnVLayer[xCoord].append(yCoord)

        for yFixed, xListAtY in pointsByYCoordOnHLayer.items():
            xListAtY.sort()
            for i in range(len(xListAtY) - 1):
                pt1Coords = (xListAtY[i], yFixed)
                pt2Coords = (xListAtY[i+1], yFixed)
                isSegmentBlocked = False
                for obsRect in obstaclesForCurrentSegments.get('HORIZONTAL', []):

                    if obsRect[0] < pt2Coords[0] and obsRect[2] > pt1Coords[0] and \
                       obsRect[1] < yFixed + 1 and obsRect[3] > yFixed -1:
                        isSegmentBlocked = True; break
                if not isSegmentBlocked and pt1Coords in graphVertexMap and pt2Coords in graphVertexMap:
                    graphVertexMap[pt1Coords]._neighborNodes.append(graphVertexMap[pt2Coords])
                    graphVertexMap[pt2Coords]._neighborNodes.append(graphVertexMap[pt1Coords])


        for xFixed, yListAtX in pointsByXCoordOnVLayer.items():
            yListAtX.sort()
            for i in range(len(yListAtX) - 1):
                pt1Coords = (xFixed, yListAtX[i])
                pt2Coords = (xFixed, yListAtX[i+1])
                isSegmentBlocked = False
                for obsRect in obstaclesForCurrentSegments.get('VERTICAL', []):
                    if obsRect[1] < pt2Coords[1] and obsRect[3] > pt1Coords[1] and \
                       obsRect[0] < xFixed + 1 and obsRect[2] > xFixed -1:
                        isSegmentBlocked = True; break
                if not isSegmentBlocked and pt1Coords in graphVertexMap and pt2Coords in graphVertexMap:
                    graphVertexMap[pt1Coords]._neighborNodes.append(graphVertexMap[pt2Coords])
                    graphVertexMap[pt2Coords]._neighborNodes.append(graphVertexMap[pt1Coords])

    for vertexObj in graphVertexMap.values():
        vertexObj._neighborNodes = list(set(vertexObj._neighborNodes))

    return graphVertexMap


def findGraphNodesInPinShapes(targetPinLayerName: str, pinRectangleObjectList: List[LEFDEFParser.Rect],
                              graphVertexMap: Dict[Tuple[int,int], GraphVertex]) -> List[GraphVertex]:
    graphInteractionLayer = 'met1' if targetPinLayerName == 'li1' else targetPinLayerName

    matchingGraphNodes: List[GraphVertex] = []
    for pinRectObj in pinRectangleObjectList:
        for vertexCoords, graphVertexObj in graphVertexMap.items():
            vtxX, vtxY = vertexCoords
            if pinRectObj.ll.x <= vtxX <= pinRectObj.ur.x and \
               pinRectObj.ll.y <= vtxY <= pinRectObj.ur.y and \
               graphInteractionLayer in graphVertexObj._layerContext:
                matchingGraphNodes.append(graphVertexObj)
    return list(set(matchingGraphNodes))
def findGraphNodesInRoutedShapes(solutionLayerName: str,
                                 solutionRectangleTupleList: List[Tuple[int,int,int,int]],
                                 graphVertexMap: Dict[Tuple[int,int], GraphVertex]) -> List[GraphVertex]:
    graphInteractionLayer = 'met1' if solutionLayerName == 'li1' else solutionLayerName
    matchingGraphNodes: List[GraphVertex] = []
    for rectTuple in solutionRectangleTupleList:
        minX, minY, maxX, maxY = rectTuple
        for vertexCoords, graphVertexObj in graphVertexMap.items():
            vtxX, vtxY = vertexCoords
            if minX <= vtxX <= maxX and minY <= vtxY <= maxY and \
               graphInteractionLayer in graphVertexObj._layerContext:
                matchingGraphNodes.append(graphVertexObj)
    return list(set(matchingGraphNodes))

def performAStarSearch(graphVertexMap: Dict[Tuple[int,int], GraphVertex],
                       sourceGraphNodes: List[GraphVertex], targetGraphNodes: List[GraphVertex],
                       spatialIndexForDrc: Optional[Dict[str, rtree.index.Index]] = None,
                       layerSpacingMapForDrc: Optional[Dict[str, float]] = None,
                       layerWidthMapForDrc: Optional[Dict[str, float]] = None,
                       enableDrcAwareness: bool = False,
                       currentNetIdForDrc: int = -1,
                       fixedObstacleIdForDrc: int = -1) -> List[GraphVertex]:

    if not sourceGraphNodes or not targetGraphNodes:
        return []

    targetNodeCoordinates = [targetNode._coordinates for targetNode in targetGraphNodes]
    def calculateMinHeuristic(vertexNode: GraphVertex) -> float:
        if not targetNodeCoordinates: return 0.0
        return min(abs(vertexNode._coordinates[0] - targetX) + abs(vertexNode._coordinates[1] - targetY) \
                   for targetX, targetY in targetNodeCoordinates)

    for graphNode in graphVertexMap.values():
        graphNode.resetStateForSearch()
        graphNode._costH = calculateMinHeuristic(graphNode)

    priorityQ = PriorityQueue()
    for startNode in sourceGraphNodes:
        startNode._costG = 0.0

        priorityQ.pushItem(startNode)

    foundPath: List[GraphVertex] = []
    nodesVisitedInSearch: Set[GraphVertex] = set()

    while not priorityQ.isEmpty():
        currentNode = priorityQ.popItem()

        if currentNode in nodesVisitedInSearch:
            continue
        nodesVisitedInSearch.add(currentNode)

        if currentNode in targetGraphNodes:
            tempPath = [currentNode]
            while tempPath[-1]._parentNode is not None:
                tempPath.append(tempPath[-1]._parentNode)
            foundPath = tempPath[::-1]
            break

        for neighborNode in currentNode._neighborNodes:
            if neighborNode in nodesVisitedInSearch:
                continue

            geometricCostOfSegment = float(dist(currentNode, neighborNode))
            drcPenaltyForSegment = 0.0

            newTotalGCost = currentNode._costG + geometricCostOfSegment + drcPenaltyForSegment
            if neighborNode._costG > newTotalGCost:
                neighborNode._costG = newTotalGCost
                neighborNode._parentNode = currentNode

                priorityQ.pushItem(neighborNode)

    return foundPath

def extractSegmentsFromPath(nodePathList: List[GraphVertex],
                            processedTrackSegmentsMap: Dict[str, Dict[int, List[Tuple[int,int]]]],
                            layerOrientationMapGlobal: Dict[str, str]) -> Dict[str, List[List[Any]]]:

    pathSegmentsByLayer: Dict[str, List[List[Any]]] = defaultdict(list)
    if not nodePathList or len(nodePathList) < 2:
        return pathSegmentsByLayer

    for i in range(len(nodePathList) - 1):
        vertexU, vertexV = nodePathList[i], nodePathList[i+1]
        x1, y1 = vertexU._coordinates
        x2, y2 = vertexV._coordinates

        segmentLayerName: Optional[str] = None
        commonLayersBetweenUV = list(set(vertexU._layerContext) & set(vertexV._layerContext))

        if not commonLayersBetweenUV: continue

        isSegmentHorizontal = (y1 == y2)
        isSegmentVertical = (x1 == x2)

        for candidateLayer in commonLayersBetweenUV:
            orientation = layerOrientationMapGlobal.get(candidateLayer)
            if isSegmentHorizontal and orientation == 'HORIZONTAL':
                if y1 in processedTrackSegmentsMap.get(candidateLayer, {}):
                    for trackXMin, trackXMax in processedTrackSegmentsMap[candidateLayer][y1]:
                        if min(x1,x2) >= trackXMin and max(x1,x2) <= trackXMax:
                            segmentLayerName = candidateLayer; break
                if segmentLayerName: break
            elif isSegmentVertical and orientation == 'VERTICAL':
                if x1 in processedTrackSegmentsMap.get(candidateLayer, {}):
                    for trackYMin, trackYMax in processedTrackSegmentsMap[candidateLayer][x1]:
                        if min(y1,y2) >= trackYMin and max(y1,y2) <= trackYMax:
                            segmentLayerName = candidateLayer; break
                if segmentLayerName: break

        if segmentLayerName:
            if isSegmentHorizontal: # y1 == y2
                pathSegmentsByLayer[segmentLayerName].append([y1, tuple(sorted((x1, x2)))])
            elif isSegmentVertical: # x1 == x2
                pathSegmentsByLayer[segmentLayerName].append([x1, tuple(sorted((y1, y2)))])

    return pathSegmentsByLayer

def isPotentialSegmentValidOnTrack(layerTrackDataMap: Dict[int, List[Tuple[int,int]]], # {fixedCoord: [(minVar, maxVar),...]}
                                   fixedTrackCoordinate: int,
                                   potentialSegmentVariableRange: Tuple[int,int]) -> bool:
    # Checks if potentialSegmentVariableRange is valid on the track at fixedTrackCoordinate
    if fixedTrackCoordinate not in layerTrackDataMap:
        return False
    for trackMinVar, trackMaxVar in layerTrackDataMap[fixedTrackCoordinate]:
        if potentialSegmentVariableRange[0] >= trackMinVar and potentialSegmentVariableRange[1] <= trackMaxVar:
            return True
    return False

def mergeCollinearPathSegments(path_map, track_map, orient_map):
    final_map = {}

    for layer, seg_list in path_map.items():
        if not seg_list:
            final_map[layer] = []
            continue

        seg_list.sort(key=lambda s: (s[0], s[1][0]))
        merged = []

        curr_fix = seg_list[0][0]
        curr_min, curr_max = seg_list[0][1]

        for next_seg in seg_list[1:]:
            next_fix = next_seg[0]
            next_min, next_max = next_seg[1]

            if next_fix == curr_fix and next_min <= curr_max + 1:
                merged_max = max(curr_max, next_max)
                if isPotentialSegmentValidOnTrack(track_map.get(layer, {}), curr_fix, (curr_min, merged_max)):
                    curr_max = merged_max
                else:
                    merged.append([curr_fix, (curr_min, curr_max)])
                    curr_fix, curr_min, curr_max = next_fix, next_min, next_max
            else:
                merged.append([curr_fix, (curr_min, curr_max)])
                curr_fix, curr_min, curr_max = next_fix, next_min, next_max

        merged.append([curr_fix, (curr_min, curr_max)])
        final_map[layer] = merged

    return final_map


def addRectanglesToNetSolution(targetDefNetObject: LEFDEFParser.Net,
                               mainNetDataList: List[NetData], targetNetIdentifier: int,
                               mergedPathSegmentsMap: Dict[str, List[List[Any]]],
                               layerOrientationMapGlobal: Dict[str, str], layerWidthMapGlobal: Dict[str, float],
                               mainSpatialIndex: Dict[str, rtree.index.Index],
                               currentRtreeEntryId: int) -> int:

    targetNetObj = mainNetDataList[targetNetIdentifier] # Get our Python NetData object

    for layerName, segmentList in mergedPathSegmentsMap.items():
        if layerName not in targetNetObj._routingSolution:
             targetNetObj._routingSolution[layerName] = [] # Ensure list exists
        if not segmentList: continue

        halfWidth = layerWidthMapGlobal.get(layerName, 0.0) / 2.0
        if halfWidth <= 1e-9 : # Effectively zero width
            print(f"  Warning: Layer {layerName} has zero/negligible width for net {targetNetObj._netName}. Skipping rectangle addition.")
            continue

        orientation = layerOrientationMapGlobal.get(layerName)
        if orientation == 'HORIZONTAL':
            for segmentData in segmentList: # segmentData is [fixed_y_coord, (min_x_coord, max_x_coord)]
                yCoord = segmentData[0]
                xMin, xMax = sorted(segmentData[1]) # Ensure min, max order
                rectTuple = (int(xMin), int(yCoord - halfWidth),
                             int(xMax), int(yCoord + halfWidth))

                targetDefNetObject.addRect(layerName, rectTuple[0], rectTuple[1], rectTuple[2], rectTuple[3])
                if layerName in mainSpatialIndex:
                    mainSpatialIndex[layerName].insert(currentRtreeEntryId, rectTuple, obj=targetNetIdentifier)
                targetNetObj._routingSolution[layerName].append(rectTuple)
                currentRtreeEntryId += 1
        elif orientation == 'VERTICAL':
            for segmentData in segmentList: # segmentData is [fixed_x_coord, (min_y_coord, max_y_coord)]
                xCoord = segmentData[0]
                yMin, yMax = sorted(segmentData[1])
                rectTuple = (int(xCoord - halfWidth), int(yMin),
                             int(xCoord + halfWidth), int(yMax))

                targetDefNetObject.addRect(layerName, rectTuple[0], rectTuple[1], rectTuple[2], rectTuple[3])
                if layerName in mainSpatialIndex:
                     mainSpatialIndex[layerName].insert(currentRtreeEntryId, rectTuple, obj=targetNetIdentifier)
                targetNetObj._routingSolution[layerName].append(rectTuple)
                currentRtreeEntryId += 1
    return currentRtreeEntryId

def findvias(layerAdjacencyMap: Dict[str, List[str]],
                              startLayerName: str, endLayerName: str) -> List[str]:
    # Performs a Depth-First Search to find a path of layers.
    if startLayerName == endLayerName: return []

    # Inner DFS recursive helper
    def dfsRecursiveSearch(currentLayer: str, targetLayer: str, currentPath: List[str], visitedLayers: Set[str]) -> Optional[List[str]]:
        if currentLayer == targetLayer:
            return currentPath

        visitedLayers.add(currentLayer)
        for neighborLayer in layerAdjacencyMap.get(currentLayer, []):
            if neighborLayer not in visitedLayers:
                foundPath = dfsRecursiveSearch(neighborLayer, targetLayer, currentPath + [neighborLayer], visitedLayers)
                if foundPath:
                    return foundPath
        return None # No path found from this branch

    pathIncludingEndpoints = dfsRecursiveSearch(startLayerName, endLayerName, [startLayerName], set())

    if pathIncludingEndpoints and len(pathIncludingEndpoints) > 2:
        return pathIncludingEndpoints[1:-1] # Exclude start and end layers themselves
    return [] # No intermediate layers found or path is direct

def addViasToNetSolution(targetDefNetObject: LEFDEFParser.Net, mainNetDataList: List[NetData], targetNetIdentifier: int,
                         currentPathSegmentsMap: Dict[str, List[List[Any]]], # Segments just added
                         pinsConnectedSoFarMap: Dict[Tuple[str,str], Dict[str, List[LEFDEFParser.Rect]]], # Pins part of current connection tree
                         sourceNodesForSegment: List[GraphVertex], targetNodesForSegment: List[GraphVertex], # Nodes from A*
                         layerOrientationMapGlobal: Dict[str, str], layerWidthMapGlobal: Dict[str, float],
                         layerAdjacencyMapGlobal: Dict[str, List[str]],
                         mainSpatialIndex: Dict[str, rtree.index.Index], currentRtreeEntryId: int,
                         findIntermediateLayersFunc: callable, doRectsOverlapFunc: callable) -> int:


    targetNetObj = mainNetDataList[targetNetIdentifier]
    viaLocationsAddedThisCall: Set[Tuple[int,int,str,str]] = set() # (x,y, lay1, lay2) to avoid duplicates

    # Iterate through the segments that were just added for the current path
    for segmentLayer, segmentListOnLayer in currentPathSegmentsMap.items():
        if not segmentListOnLayer: continue

        halfWidthCurrentLayer = layerWidthMapGlobal.get(segmentLayer, 0.0) / 2.0
        if halfWidthCurrentLayer <= 1e-9: continue

        orientationCurrentLayer = layerOrientationMapGlobal.get(segmentLayer)

        for currentSegmentData in segmentListOnLayer: # e.g., [fixed_coord, (var_min, var_max)]
            # Reconstruct the rectangle for the current segment
            currentSegmentRectTuple: Tuple[int,int,int,int]
            if orientationCurrentLayer == 'HORIZONTAL':
                yFixed, (xMin, xMax) = currentSegmentData[0], sorted(currentSegmentData[1])
                currentSegmentRectTuple = (int(xMin), int(yFixed - halfWidthCurrentLayer),
                                           int(xMax), int(yFixed + halfWidthCurrentLayer))
            elif orientationCurrentLayer == 'VERTICAL':
                xFixed, (yMin, yMax) = currentSegmentData[0], sorted(currentSegmentData[1])
                currentSegmentRectTuple = (int(xFixed - halfWidthCurrentLayer), int(yMin),
                                           int(xFixed + halfWidthCurrentLayer), int(yMax))
            else: continue
            for pinTupleKey, pinShapesByLayerMap in pinsConnectedSoFarMap.items():
                for pinShapeLayer, pinRectObjectList in pinShapesByLayerMap.items():
                    for pinRectObject in pinRectObjectList:
                        pinRectTuple = (pinRectObject.ll.x, pinRectObject.ll.y, pinRectObject.ur.x, pinRectObject.ur.y)

                        if doRectsOverlapFunc(currentSegmentRectTuple, pinRectTuple):
                            # Overlap detected. If layers are not adjacent, a via stack is needed.
                            if pinShapeLayer in layerAdjacencyMapGlobal.get(segmentLayer, []):
                                continue
                            viaPlacementCoord: Optional[Tuple[int,int]] = None
                            # Try to find a common A* graph node within both overlapping shapes
                            for graphNodeCandidate in sourceNodesForSegment + targetNodesForSegment:
                                nodeX, nodeY = graphNodeCandidate._coordinates
                                # Check if node is in currentSegmentRectTuple
                                if currentSegmentRectTuple[0] <= nodeX <= currentSegmentRectTuple[2] and \
                                   currentSegmentRectTuple[1] <= nodeY <= currentSegmentRectTuple[3]:
                                    # Check if node is in pinRectTuple
                                    if pinRectTuple[0] <= nodeX <= pinRectTuple[2] and \
                                       pinRectTuple[1] <= nodeY <= pinRectTuple[3]:
                                        viaPlacementCoord = (nodeX, nodeY)
                                        break
                            if not viaPlacementCoord: # Fallback: center of overlap (crude)
                                overlapMinX = max(currentSegmentRectTuple[0], pinRectTuple[0])
                                overlapMinY = max(currentSegmentRectTuple[1], pinRectTuple[1])
                                overlapMaxX = min(currentSegmentRectTuple[2], pinRectTuple[2])
                                overlapMaxY = min(currentSegmentRectTuple[3], pinRectTuple[3])
                                if overlapMinX < overlapMaxX and overlapMinY < overlapMaxY:
                                     viaPlacementCoord = ( (overlapMinX + overlapMaxX)//2, (overlapMinY + overlapMaxY)//2 )

                            if viaPlacementCoord:
                                intermediateLayersList = findIntermediateLayersFunc(layerAdjacencyMapGlobal, segmentLayer, pinShapeLayer)
                                viaPathLayers = [segmentLayer] + intermediateLayersList + [pinShapeLayer]

                                for kStack in range(len(viaPathLayers) - 1):
                                    layerA = viaPathLayers[kStack]
                                    layerB = viaPathLayers[kStack+1]

                                    viaKey = tuple(sorted((layerA, layerB))) + viaPlacementCoord
                                    if viaKey in viaLocationsAddedThisCall: continue # Avoid redundant via

                                    viaRepLayer = layerA # Default to one of them
                                    if layerA.startswith('met') and layerB.startswith('met'):
                                        viaRepLayer = min(layerA, layerB, key=lambda l: int(l[3:])) # met1 < met2
                                    elif layerA == 'li1' or layerB == 'li1': viaRepLayer = 'li1'

                                    viaHalfW = layerWidthMapGlobal.get(viaRepLayer, 100) / 2.0 # Default width 100

                                    viaRectTuple = (int(viaPlacementCoord[0] - viaHalfW), int(viaPlacementCoord[1] - viaHalfW),
                                                    int(viaPlacementCoord[0] + viaHalfW), int(viaPlacementCoord[1] + viaHalfW))

                                    for viaComponentLayer in [layerA, layerB]:
                                        targetDefNetObject.addRect(viaComponentLayer, viaRectTuple[0], viaRectTuple[1], viaRectTuple[2], viaRectTuple[3])
                                        if viaComponentLayer not in targetNetObj._routingSolution: targetNetObj._routingSolution[viaComponentLayer] = []
                                        targetNetObj._routingSolution[viaComponentLayer].append(viaRectTuple)

                                    viaLocationsAddedThisCall.add(viaKey)

    return currentRtreeEntryId

def identifyDrcViolationsFromChecker(output_def, golden_def, lef_file, net_list, check_func):
    violated_ids = set()
    original_stdout = sys.stdout
    sys.stdout = captured = io.StringIO()

    check_func(output_def, golden_def, lef_file, False)

    sys.stdout = original_stdout
    output_text = captured.getvalue()

    net_name_to_id = {net._netName: net._netIdentifier for net in net_list}

    for line in output_text.splitlines():
        if "Spacing violation :" in line:
            try:
                json_str = line.split("Spacing violation :", 1)[1].strip()
                violations = ast.literal_eval(json_str)
                for v in violations:
                    if 'net1' in v and v['net1'] in net_name_to_id:
                        violated_ids.add(net_name_to_id[v['net1']])
                    if 'net2' in v and v['net2'] != 'obst' and v['net2'] in net_name_to_id:
                        violated_ids.add(net_name_to_id[v['net2']])
            except Exception:
                pass

    if violated_ids:
        print(f"  DRC Spacing violations identified in net IDs: {violated_ids}")
    return list(violated_ids)


# --- Main Orchestration Function ---
def detailed_route(inputDefFilePath: str, inputLefFilePath: str,
                              inputGuideFilePath: str, outputDefFilePath: str):

    routingStartTime = time.time()
    print(f"Starting Detailed Routing Process:")
    print(f"  Input DEF:   {inputDefFilePath}")
    print(f"  Input LEF:   {inputLefFilePath}")
    print(f"  Input GUIDE: {inputGuideFilePath}")
    print(f"  Output DEF:  {outputDefFilePath}\n")

    # --- 1. Initialization: Load LEF/DEF, Tracks, Global Routes ---
    # Load LEF data
    lefReader = LEFDEFParser.LEFReader()
    lefReader.readLEF(inputLefFilePath)
    macroDefinitionMap: Dict[str, LEFDEFParser.Macro] = {macro.name(): macro for macro in lefReader.macros()}

    # Load DEF data
    defReader = LEFDEFParser.DEFReader()
    defReader.readDEF(inputDefFilePath)

    # Populate global layer characteristic maps (width, spacing) from LEF
    myLayerWidthMap.clear()
    myLayerSpacingMap.clear()
    for lefLayerObject in lefReader.layers():
        myLayerWidthMap[lefLayerObject.name()] = lefLayerObject.width()
        try:
            # Assuming pitch() gives total pitch. Spacing = Pitch - Width.
            calculatedSpacing = lefLayerObject.pitch() - lefLayerObject.width()
            # Ensure spacing is not negative (e.g. if pitch is smaller than width due to LEF definition)
            myLayerSpacingMap[lefLayerObject.name()] = max(calculatedSpacing, lefLayerObject.width() * 0.5) # Min spacing as half width
        except AttributeError: # If pitch() method is not available
            print(f"  Warning: Pitch information not found for layer {lefLayerObject.name()}. Using default spacing (equal to width).")
            myLayerSpacingMap[lefLayerObject.name()] = lefLayerObject.width() # Fallback default

    # Create InstanceData objects
    instanceDataMap: Dict[str, InstanceData] = {
        component.name(): InstanceData(component, macroDefinitionMap[component.macro()])
        for component in defReader.components() if component.macro() not in mySkipCellNames
    }

    # Process boundary pins (PINS section in DEF)
    boundaryPinDataMap: Dict[str, Dict[str, List[LEFDEFParser.Rect]]] = {}
    for defPinObject in defReader.pins():
        pinName = defPinObject.name()
        boundaryPinDataMap[pinName] = defaultdict(list)
        for portDict in defPinObject.ports(): # ports() returns List[Dict[str, List[Rect]]]
            for layerName, rectObjectListFromParser in portDict.items():
                # Parser gives LEFDEFParser.Rect, ensure they are stored as such or compatible type
                boundaryPinDataMap[pinName][layerName].extend(rectObjectListFromParser)

    # Create NetData objects and calculate initial HPWL
    netDataList: List[NetData] = []
    netIdCounter = 0
    for defNetObject in defReader.nets():
        if defNetObject.name() not in mySkipNetNames:
            # HPWL Calculation (simplified, from original notebook)
            minXHpWl, minYHpWl, maxXHpWl, maxYHpWl = math.inf, math.inf, -math.inf, -math.inf
            for pinTupleHpWl in defNetObject.pins():
                pinPositionHpWl: Tuple[float,float]
                if pinTupleHpWl[0] != 'PIN': # Instance pin
                    instObjHpWl = instanceDataMap.get(pinTupleHpWl[0])
                    if instObjHpWl: # Use center of instance bounding box
                        pinPositionHpWl = (instObjHpWl._bBox.ll.x + (instObjHpWl._bBox.ur.x - instObjHpWl._bBox.ll.x) / 2,
                                           instObjHpWl._bBox.ll.y + (instObjHpWl._bBox.ur.y - instObjHpWl._bBox.ll.y) / 2)
                    else: continue # Should not happen if DEF is consistent
                else: # Boundary pin
                    pinShapesHpWl = boundaryPinDataMap.get(pinTupleHpWl[1])
                    if pinShapesHpWl and any(pinShapesHpWl.values()):
                        firstLayerNameHpWl = next(iter(pinShapesHpWl.keys())) # Get first layer with shapes
                        firstRectHpWl = pinShapesHpWl[firstLayerNameHpWl][0]
                        pinPositionHpWl = ((firstRectHpWl.ll.x + firstRectHpWl.ur.x) / 2,
                                           (firstRectHpWl.ll.y + firstRectHpWl.ur.y) / 2)
                    else: continue # Pin has no shapes

                minXHpWl, maxXHpWl = min(minXHpWl, pinPositionHpWl[0]), max(maxXHpWl, pinPositionHpWl[0])
                minYHpWl, maxYHpWl = min(minYHpWl, pinPositionHpWl[1]), max(maxYHpWl, pinPositionHpWl[1])

            estimatedWirelength = (maxXHpWl - minXHpWl) + (maxYHpWl - minYHpWl) # In DEF units
            netDataList.append(NetData(defNetObject, instanceDataMap, boundaryPinDataMap, netIdCounter, estimatedWirelength))
            netIdCounter += 1

    bbox: LEFDEFParser.Rect = defReader.bbox()

    # Process TRACKS from DEF to create chipTrackLayoutMap
    # Structure: {layerName: {trackCoordinate: [(minExtent, maxExtent), ...]}}
    chipTrackLayoutMap: Dict[str, Dict[int, List[Tuple[int,int]]]] = defaultdict(lambda: defaultdict(list))
    for layerNameFromTracks, gridObjectListFromTracks in defReader.tracks().items():
        if layerNameFromTracks in myLayerOrientationMap:
            orientationOfTrack = myLayerOrientationMap[layerNameFromTracks]
            for defGridObject in gridObjectListFromTracks: # defGridObject is LEFDEFParser.Grid
                # defGridObject.x is startCoord, .step is pitch, .num is count
                for iTrackNum in range(defGridObject.num):
                    trackFixedCoordinate = defGridObject.x + iTrackNum * defGridObject.step
                    if orientationOfTrack == 'VERTICAL': # Vertical track at X = trackFixedCoordinate
                        chipTrackLayoutMap[layerNameFromTracks][trackFixedCoordinate].append(
                            (bbox.ll.y, bbox.ur.y)
                        )
                    elif orientationOfTrack == 'HORIZONTAL': # Horizontal track at Y = trackFixedCoordinate
                        chipTrackLayoutMap[layerNameFromTracks][trackFixedCoordinate].append(
                            (bbox.ll.x, bbox.ur.x)
                        )

    # Parse global routing guide file
    globalRoutingSolutionMap: Dict[str, List[Tuple[int,int,int,int,str]]] = {} # {netName: [(x1,y1,x2,y2,layer), ...]}
    try:
        with open(inputGuideFilePath, 'r') as guideFile:
            guideFileLines = guideFile.readlines()
        lineIdxGuide = 0
        while lineIdxGuide < len(guideFileLines):
            currentGuideLine = guideFileLines[lineIdxGuide].strip()
            if currentGuideLine == '(': # Start of a net's geometries
                netNameFromGuide = guideFileLines[lineIdxGuide-1].strip() # Net name is on previous line
                lineIdxGuide += 1
                geometriesForNet: List[Tuple[int,int,int,int,str]] = []
                while lineIdxGuide < len(guideFileLines) and guideFileLines[lineIdxGuide].strip() != ')':
                    guideTokens = guideFileLines[lineIdxGuide].strip().split()
                    if len(guideTokens) == 5: # x1 y1 x2 y2 layer
                        try:
                            x1g, y1g, x2g, y2g = map(int, guideTokens[:4])
                            layerNameG = guideTokens[4]
                            geometriesForNet.append((x1g, y1g, x2g, y2g, layerNameG))
                        except ValueError:
                            print(f"  Warning: Could not parse guide geometry: {guideFileLines[lineIdxGuide].strip()}")
                    lineIdxGuide += 1
                globalRoutingSolutionMap[netNameFromGuide] = geometriesForNet
            lineIdxGuide += 1
    except FileNotFoundError:
        print(f"  ERROR: Global routing guide file '{inputGuideFilePath}' not found. Cannot proceed.")
        return

    # Build R-tree for fixed obstacles
    mainSpatialIndex, rtreeEntryIdCounter, fixedObstacleIdentifier = buildTree(netDataList, instanceDataMap)

    # Build a separate R-tree for li1 pins (treated as obstacles on met1)
    li1PinSpatialIndex = rtree.index.Index()
    li1PinRtreeIdCounter = 0
    for netDataObjLi1 in netDataList:
        for pinTupleLi1, pinShapesByLayerLi1 in netDataObjLi1._pinConnections.items():
            if 'li1' in pinShapesByLayerLi1:
                for rectObjLi1 in pinShapesByLayerLi1['li1']:
                    li1PinSpatialIndex.insert(li1PinRtreeIdCounter,
                                            (rectObjLi1.ll.x, rectObjLi1.ll.y, rectObjLi1.ur.x, rectObjLi1.ur.y),
                                            obj=netDataObjLi1._netIdentifier) # Store net ID as obj
                    li1PinRtreeIdCounter += 1

    # Sort nets by wirelength for processing order
    sortedNetIdsByWirelength: List[Tuple[int, float]] = sorted(
        [(netData._netIdentifier, netData._wireLengthEstimate) for netData in netDataList],
        key=lambda item: item[1] # Sort by wirelength (item[1])
    )

    globalCornerCaseTestLayers: List[str] = ['li1', 'met1'] # For specific handling from original notebook logic


    for currentNetIdTuple in sortedNetIdsByWirelength:
        currentNetId = currentNetIdTuple[0] # Get the net ID
        targetNetObject = netDataList[currentNetId]

        currentNetPinTuples = list(targetNetObject._pinConnections.items())
        if not currentNetPinTuples or len(currentNetPinTuples) < 2:
            print(f"    Net {targetNetObject._netName} has < 2 pins. Skipping.")
            continue

        connectedPinsOnCurrentNet = dict([currentNetPinTuples[0]])
        unrouted = dict(currentNetPinTuples[1:])
        sourceGraphNodes: List[GraphVertex] = []
        firstPinNameTuple, firstPinShapesByLayer = currentNetPinTuples[0]

        if targetNetObject._netName not in globalRoutingSolutionMap:
            print(f"    No global guide for {targetNetObject._netName}. Skipping.")
            continue

        activeLayersForNetStrList = [gs[-1] for gs in globalRoutingSolutionMap[targetNetObject._netName]]
        activeLayersForNetStrList = sorted(list(set(activeLayersForNetStrList)))

        isCornerCaseNet = (activeLayersForNetStrList == globalCornerCaseTestLayers)
        if isCornerCaseNet:
            if 'li1' in activeLayersForNetStrList: activeLayersForNetStrList.remove('li1')
            if 'met2' not in activeLayersForNetStrList: activeLayersForNetStrList.append('met2')
        elif 'li1' in activeLayersForNetStrList:
            activeLayersForNetStrList.remove('li1')
        activeLayersForNetStrList = sorted(list(set(activeLayersForNetStrList)))

        if not activeLayersForNetStrList: continue

        currentNetPinShapesToIgnore: Dict[str, List[List[int]]] = defaultdict(list)
        for pt, psbl in targetNetObject._pinConnections.items():
            for ln, rlist in psbl.items():
                gil = 'met1' if ln == 'li1' else ln
                if gil in activeLayersForNetStrList or gil == 'met1':
                    for r_obj in rlist:
                        currentNetPinShapesToIgnore[gil].append([r_obj.ll.x, r_obj.ll.y, r_obj.ur.x, r_obj.ur.y])

        guidesByLayerForNet: Dict[str, List[Tuple[int,int,int,int]]] = defaultdict(list)
        for layerNameGuide in activeLayersForNetStrList:
            ggfl = [g[:-1] for g in globalRoutingSolutionMap[targetNetObject._netName] if g[-1] == layerNameGuide]
            pgRects = mergeRectangleList(ggfl)
            if isCornerCaseNet and layerNameGuide == 'met2':
                guidesByLayerForNet[layerNameGuide] = guidesByLayerForNet.get('met1', pgRects)
            else:
                guidesByLayerForNet[layerNameGuide] = pgRects

        activeLayerPairsForNet: Set[Tuple[str,str]] = set()
        for l1n in activeLayersForNetStrList:
            for l2na in gAdjacentLayerMap.get(l1n, []):
                if l2na != 'li1' and l2na in activeLayersForNetStrList:
                    activeLayerPairsForNet.add(tuple(sorted((l1n, l2na))))

        refinedGuidesByLayerForNet: Dict[str, List[Tuple[int,int,int,int]]] = defaultdict(list)
        for l1p, l2p in activeLayerPairsForNet:
            cgfp = guidesByLayerForNet.get(l1p, []) + guidesByLayerForNet.get(l2p, [])
            ppg = mergeRectangleList(cgfp)
            refinedGuidesByLayerForNet[l1p].extend(ppg)
            refinedGuidesByLayerForNet[l2p].extend(ppg)
        for lnfr, rlfr in refinedGuidesByLayerForNet.items():
            refinedGuidesByLayerForNet[lnfr] = mergeRectangleList(rlfr)

        processedTrackSegmentsForNet: Dict[str, Dict[int, List[Tuple[int,int]]]] = defaultdict(lambda: defaultdict(list))
        for layerNameTrackGen in activeLayersForNetStrList:
            if layerNameTrackGen not in refinedGuidesByLayerForNet or not refinedGuidesByLayerForNet[layerNameTrackGen]:
                continue
            trackOrientChar = myLayerOrientationMap[layerNameTrackGen][0]
            for guideRectTupleTrackGen in refinedGuidesByLayerForNet[layerNameTrackGen]:
                generateGridTracksInGuide(processedTrackSegmentsForNet, chipTrackLayoutMap, layerNameTrackGen,
                                       trackOrientChar, guideRectTupleTrackGen)
            if layerNameTrackGen in processedTrackSegmentsForNet:
                consolidateTrackSegments(processedTrackSegmentsForNet[layerNameTrackGen])

        routingGraphForNet = buildRoutingGraph(
            activeLayerPairsForNet, refinedGuidesByLayerForNet, currentNetPinShapesToIgnore,
            processedTrackSegmentsForNet, mainSpatialIndex, li1PinSpatialIndex,
            myLayerOrientationMap, fixedObstacleIdentifier,
            True # <<< routeAggressivelyFlag = True for initial pass
        )

        if not routingGraphForNet:
            print(f"    Net {targetNetObject._netName}: Routing graph empty for initial pass. Skipping.")
            continue

        for layerNamePin1, rectListPin1 in firstPinShapesByLayer.items():
             sourceGraphNodes.extend(
                 findGraphNodesInPinShapes(layerNamePin1, rectListPin1, routingGraphForNet)
             )
        sourceGraphNodes = list(set(sourceGraphNodes))
        if not sourceGraphNodes:
            print(f"    Net {targetNetObject._netName}: No source nodes for first pin. Skipping.")
            continue

        while unrouted:
            nextTargetPinNameTuple, nextTargetShapesByLayer = unrouted.popitem()
            connectedPinsOnCurrentNet[nextTargetPinNameTuple] = nextTargetShapesByLayer
            targetGraphNodes: List[GraphVertex] = []
            for target_lay_name, rect_target in nextTargetShapesByLayer.items():
                targetGraphNodes.extend(
                    findGraphNodesInPinShapes(target_lay_name, rect_target, routingGraphForNet)
                )
            targetGraphNodes = list(set(targetGraphNodes))

            if not targetGraphNodes: continue

            # Simplified met1 obstacle filtering for source/target (original notebook logic)
            if 'met1' in refinedGuidesByLayerForNet and refinedGuidesByLayerForNet['met1'] and \
               'met1' in mainSpatialIndex and sourceGraphNodes and targetGraphNodes: # Ensure met1 exists
                nodesToRemoveFromSource: Set[GraphVertex] = set()
                nodesToRemoveFromTarget: Set[GraphVertex] = set()
                met1NotObsForFilter = currentNetPinShapesToIgnore.get('met1', [])
                for guideM1Filter in refinedGuidesByLayerForNet['met1']:
                    for rtreeHitM1 in list(mainSpatialIndex['met1'].intersection(guideM1Filter, objects=True)):
                        if rtreeHitM1.bbox in met1NotObsForFilter: continue
                        if rtreeHitM1.object == fixedObstacleIdentifier or rtreeHitM1.object != currentNetId : # Consider fixed obst or other nets
                            for sNode in sourceGraphNodes:
                                if rtreeHitM1.bbox[0] <= sNode._coordinates[0] <= rtreeHitM1.bbox[2] and \
                                   rtreeHitM1.bbox[1] <= sNode._coordinates[1] <= rtreeHitM1.bbox[3]:
                                    nodesToRemoveFromSource.add(sNode)
                            for tNode in targetGraphNodes:
                                if rtreeHitM1.bbox[0] <= tNode._coordinates[0] <= rtreeHitM1.bbox[2] and \
                                   rtreeHitM1.bbox[1] <= tNode._coordinates[1] <= rtreeHitM1.bbox[3]:
                                    nodesToRemoveFromTarget.add(tNode)
                sourceGraphNodes = [s for s in sourceGraphNodes if s not in nodesToRemoveFromSource]
                targetGraphNodes = [t for t in targetGraphNodes if t not in nodesToRemoveFromTarget]

            if not sourceGraphNodes or not targetGraphNodes: continue

            for graphVertexObjReset in routingGraphForNet.values(): graphVertexObjReset.resetStateForSearch()

            # A* for initial pass should be DRC-agnostic for other nets, graph handles fixed obstacles
            foundNodePath = performAStarSearch(
                routingGraphForNet, sourceGraphNodes, targetGraphNodes,
                enableDrcAwareness=False # DRC awareness in A* is off for initial pass
            )

            if not foundNodePath: continue

            rawSegmentsFromPath = extractSegmentsFromPath(foundNodePath, processedTrackSegmentsForNet, myLayerOrientationMap)
            mergedSegmentsForRouting = mergeCollinearPathSegments(rawSegmentsFromPath, processedTrackSegmentsForNet, myLayerOrientationMap)

            defNetObjectToWriteTo: Optional[LEFDEFParser.Net] = None
            for defParserNetObjLoop in defReader.nets():
                if defParserNetObjLoop.name() == targetNetObject._netName:
                    defNetObjectToWriteTo = defParserNetObjLoop; break

            if defNetObjectToWriteTo:
                rtreeEntryIdCounter = addRectanglesToNetSolution(
                    defNetObjectToWriteTo, netDataList, currentNetId, mergedSegmentsForRouting,
                    myLayerOrientationMap, myLayerWidthMap, mainSpatialIndex, rtreeEntryIdCounter
                )
                rtreeEntryIdCounter = addViasToNetSolution(
                    defNetObjectToWriteTo, netDataList, currentNetId, mergedSegmentsForRouting,
                    connectedPinsOnCurrentNet, sourceGraphNodes, targetGraphNodes,
                    myLayerOrientationMap, myLayerWidthMap, gAdjacentLayerMap, mainSpatialIndex,
                    rtreeEntryIdCounter, findvias, overlap1
                )

            updatedSourceNodes: List[GraphVertex] = []
            for solLayerName, solRectTupleList in targetNetObject._routingSolution.items():
                if solRectTupleList:
                     updatedSourceNodes.extend(
                         findGraphNodesInRoutedShapes(solLayerName, solRectTupleList, routingGraphForNet)
                     )
            sourceGraphNodes = list(set(updatedSourceNodes))
            if not sourceGraphNodes: break # Stop if net becomes fragmented

        # Perform DRC check after each net is routed (as in original notebook for debugging)
        # defReader.writeDEF(outputDefFilePath)
        # print(f"    DRC Check after initial routing of net {targetNetObject._netName}:")
        # loadAndCheck(outputDefFilePath, inputDefFilePath, inputLefFilePath, False)

    defReader.writeDEF(outputDefFilePath)
    loadAndCheck(outputDefFilePath, inputDefFilePath, inputLefFilePath, False)
detailed_route(deffile, leffile, gr_filepath, "out.def")

