# -*- coding: utf-8 -*-
"""B&B.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18Mb7E761iQLS53-ht4pvxV5-XH7cv8tJ
"""

!pip install mip

import numpy as np
import math
from mip import Model, maximize, minimize

def round_rhs(rhs, sense):
    if sense == '<':
        return math.floor(rhs)
    elif sense == '>':
        return math.ceil(rhs)
    elif sense == '=':
        return round(rhs)
    return rhs

def is_integer(val, tolerance=1e-7):
    return abs(val - round(val)) <= tolerance

def pick_fractional_index(sol, int_vars, tolerance=1e-7):
    fractional_parts = [(i, abs(sol[i] - round(sol[i]))) for i in int_vars if abs(sol[i] - round(sol[i])) > tolerance]
    if not fractional_parts:
        return None
    return min(fractional_parts, key=lambda x: -x[1])[0]

def two_phase_simplex(m, obj, maximize_flag, verbose=False):
    varMap = {v.name: i for i, v in enumerate(m.vars)}
    n_vars = len(m.vars)
    n_cons = len(m.constrs)

    A_rows = []
    b = []
    basis = []
    artificial_cols = []

    try:
        for idx, con in enumerate(m.constrs):
            row = [0] * n_vars
            for var, coeff in con.expr.expr.items():
                row[varMap[var.name]] = coeff

            rhs = con.rhs
            sense = con.expr.sense
            rhs = round_rhs(rhs, sense)

            slack = [0] * n_cons
            artificial = [0] * n_cons

            if sense == '<':
                slack[idx] = 1
                basic_col = n_vars + idx
            elif sense == '>':
                slack[idx] = -1
                artificial[idx] = 1
                basic_col = n_vars + n_cons + idx
                artificial_cols.append(n_vars + n_cons + idx)
            elif sense == '=':
                artificial[idx] = 1
                basic_col = n_vars + n_cons + idx
                artificial_cols.append(n_vars + n_cons + idx)
            else:
                return [None] * n_vars, None

            A_rows.append(row + slack + artificial)
            b.append(rhs)
            basis.append(basic_col)

        A = np.array(A_rows, dtype=float)
        b = np.array(b, dtype=float)

        num_total_vars = A.shape[1]

        # Phase I
        c1 = np.zeros(num_total_vars)
        for col in artificial_cols:
            c1[col] = 1

        f1 = 0

        for i, col in enumerate(basis):
            if col in artificial_cols:
                c1 -= A[i]
                f1 -= b[i]

        if verbose:
            print("==== Phase I ====")

        while np.any(c1 < -1e-8):
            pivot_col = np.argmin(c1)
            ratios = [b[i] / A[i][pivot_col] if A[i][pivot_col] > 1e-8 else np.inf for i in range(len(b))]
            if all(r == np.inf for r in ratios):
                raise Exception("Unbounded Phase I.")
            pivot_row = np.argmin(ratios)

            pivot_val = A[pivot_row][pivot_col]
            A[pivot_row] /= pivot_val
            b[pivot_row] /= pivot_val
            for i in range(len(b)):
                if i != pivot_row:
                    factor = A[i][pivot_col]
                    A[i] -= factor * A[pivot_row]
                    b[i] -= factor * b[pivot_row]
            factor = c1[pivot_col]
            c1 -= factor * A[pivot_row]
            f1 -= factor * b[pivot_row]

            basis[pivot_row] = pivot_col

        if abs(f1) > 1e-5:
            return [None] * n_vars, None

        A = np.delete(A, artificial_cols, axis=1)

        # Fix varMap after deleting columns
        new_varMap = {}
        cnt = 0
        for var_name, idx in varMap.items():
            if idx not in artificial_cols:
                new_varMap[var_name] = cnt
                cnt += 1

        # Phase II
        c2 = np.zeros(A.shape[1])
        sign = 1 if maximize_flag else -1
        for var, coeff in obj.expr.items():
            if var.name in new_varMap:
                c2[new_varMap[var.name]] = sign * coeff

        f2 = 0

        if verbose:
            print("==== Phase II ====")

        while np.any(c2 > 1e-8):
            pivot_col = np.argmax(c2)
            ratios = [b[i] / A[i][pivot_col] if A[i][pivot_col] > 1e-8 else np.inf for i in range(len(b))]
            if all(r == np.inf for r in ratios):
                raise Exception("Unbounded Phase II.")
            pivot_row = np.argmin(ratios)

            pivot_val = A[pivot_row][pivot_col]
            A[pivot_row] /= pivot_val
            b[pivot_row] /= pivot_val
            for i in range(len(b)):
                if i != pivot_row:
                    factor = A[i][pivot_col]
                    A[i] -= factor * A[pivot_row]
                    b[i] -= factor * b[pivot_row]
            factor = c2[pivot_col]
            c2 -= factor * A[pivot_row]
            f2 -= factor * b[pivot_row]

            basis[pivot_row] = pivot_col

        final_sol = [0.0] * n_vars
        for i, col in enumerate(basis):
            if col < len(final_sol):
                final_sol[col] = b[i]

        final_value = -f2 if maximize_flag else f2

        return final_sol, final_value

    except Exception as e:
        print(f"Error: {e}")
        return [None] * n_vars, None

import mip
from copy import deepcopy
import math

def solve_lp_relaxation(model):
    model.verbose = 0
    status = model.optimize(relax=True)
    if status == mip.OptimizationStatus.OPTIMAL:
        return [v.x for v in model.vars], model.objective_value
    return None, None

def is_integer(x, eps=1e-5):
    return abs(x - round(x)) < eps

def pick_branch_variable(solution, eps=1e-5):
    for idx, val in enumerate(solution):
        if not is_integer(val, eps):
            return idx
    return None

def branch_and_bound(model, minimize_problem=True):
    best_solution = None
    best_obj = float('inf') if minimize_problem else float('-inf')

    def recurse(current_model):
        nonlocal best_solution, best_obj

        sol, obj = solve_lp_relaxation(current_model)
        if sol is None:
            return

        if minimize_problem and obj >= best_obj:
            return
        if not minimize_problem and obj <= best_obj:
            return

        idx = pick_branch_variable(sol)
        if idx is None:
            # Integer feasible solution
            if (minimize_problem and obj < best_obj) or (not minimize_problem and obj > best_obj):
                best_solution = [round(x) for x in sol]
                best_obj = obj
            return

        # Branch on variable idx
        floor_val = math.floor(sol[idx])
        ceil_val = math.ceil(sol[idx])

        # Left branch: var <= floor_val
        model_left = deepcopy(current_model)
        model_left += model_left.vars[idx] <= floor_val
        recurse(model_left)

        # Right branch: var >= ceil_val
        model_right = deepcopy(current_model)
        model_right += model_right.vars[idx] >= ceil_val
        recurse(model_right)

    recurse(model)
    return best_solution, best_obj